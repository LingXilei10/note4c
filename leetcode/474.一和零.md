```
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(auto str:strs)  {
            int zeronum=0,onenum=0;
            for(auto s:str){
                if(s=='0') zeronum++;
                else onenum++;
            }
            for(int i=m;i>=zeronum;i--){
                for(int j=n;j>=onenum;j--){
                    dp[i][j] = max(dp[i][j],dp[i-zeronum][j-onenum]+1);
                }
            }
        } 
        return dp[m][n];
    }
};
```
**dp矩阵含义：** 字符串子集中满足1和0的个数<= i and j的最大自己个数

**求dp逻辑：**  这里不是累计方案个数，而是看”背包最多能装多少个物品“

物品重量：是二维的，0个数 and 1个数 决定

物品价值：多一个字符串就加一

**结构是：**

一层循环遍历物品 矩阵每个元素 => 这里是指每个字符串

二层循环遍历背包容量 => 这里的背包是二维的，0个数 and 1个数 决定
