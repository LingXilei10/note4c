```
class Solution {
public:
   bool wordBreak(string s, vector<string>& wordDict) {
       vector<bool> dp(s.size()+1, false);
       dp[0] = true;
       for (int i=0; i<s.size()+1; ++i){
           for (auto word : wordDict){
               int word_len = word.size();
               if (word_len <= i){
                   if ((s.substr(i-word_len, word_len) == word) && dp[i-word_len]==true){
                       dp[i] = true;
                   }
               }
           }
       }
       return dp[s.size()];
   }
};
```

外层循环遍历背包大小 

内层循环遍历物品 => 字符串仓库


 内部循环逻辑：如果碰到大小合适的字符串就判断：
 
       [ i-word_lend, i] 的字符串 为 word 并且 [0,i-word_len]已经匹配成功    
       
         => dp[i] = true
         
+ s.substr(pos, len)

+ from 代码随想录

求组合数：动态规划：518.零钱兑换II (opens new window)求排列数：动态规划：377. 组合总和 Ⅳ (opens new window)、动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)求最小数：动态规划：322. 零钱兑换 (opens new window)、动态规划：279.完全平方数(opens new window)

而本题其实我们求的是排列数，为什么呢。 拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。

"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

所以说，本题一定是 先遍历 背包，再遍历物品。
