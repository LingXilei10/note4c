```
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int result=0;
        vector<vector<int>> dp(nums.size(),vector<int>(target,0));
        for(int i=0;nums[i]<target;i++){
            for(int j=target;j>=nums[j];j--){
                dp[j]=max(dp[j]-nums[i],dp[j-nums[i]]+nums[i]);
                if(dp[j]==target) result++;
            }
        }
        return result;

    }
};
```

首先，利用nums[i]<target作为约束条件，如果所有的nums矩阵都小于target，那么索引会越界
且使用target作为内循环的开始索引，target本身可能就为负数


```
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum=0;
        for(auto e:nums) sum+=e;
        
        if((sum+target)%2||abs(target)>sum) return 0;
        int pos=(sum+target)/2;
        vector<int> dp(pos+1,0);
        dp[0]=1;
        for(int e:nums){
            for(int j=pos;j>=e;j--){
                dp[j]+=dp[j-e];
            }
        }
        return dp[pos];
    }
};
```

问题转化为 将矩阵里的元素分为pos与neg两个子集
```
target = pos - neg
sum = pos + neg
pos = (sum + target) / 2
```

因此新的背包重量目标就为pos

限制条件： 若sum + target不能被2整除 、 target超出sum， 则没有方案

初始值： dp[0] = 1，什么都不放成为一种方案

dp矩阵运算： 与前面看看能放到最多有多少石头 = > max(不含第i个石头，包含第i个石头）
这里需要求方案总数，因此为 dp[i][j] = dp[i-1][j]+dp[i-1][j-nums[i]]

滚动数组： dp[j] = 上一个dp[j] + 上一个的dp[j-nums[i]]
          dp[j] += dp[j-nums[i]]      
          ！ 倒序枚举j
最终返回dp[pos]


