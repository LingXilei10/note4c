## 定义

管理软硬件资源，为程序提供服务

![img](E:\076lxl\work\note4c\os\assets\OS-structure2.png)

这个图展示了三种不同类型的操作系统架构：单体内核（Monolithic Kernel）、微内核（Microkernel）和混合内核（"Hybrid kernel"）。每种架构都有其特定的组件和通信方式。以下是对图中每种架构的详细解释：

### 1. 宏内核（Monolithic Kernel）架构
- **特点**：
  - 所有的操作系统服务，如进程管理、内存管理、文件系统、设备驱动等，都运行在内核模式下。
  - 内核是一个大的、统一的二进制文件，包含了所有系统调用的实现。

- **组件**：
  - **内核模式**：包含虚拟文件系统（VFS）、系统调用（System call）、进程间通信（IPC）、文件系统（File System）、调度器（Scheduler）、虚拟内存（Virtual Memory）和设备驱动（Device Drivers）等。
  - **用户模式**：运行应用程序。

- **通信方式**：
  - 应用程序通过系统调用来请求内核服务。

### 2. 微内核（Microkernel）架构
- **特点**：
  - 微内核只包含最基本的服务，如进程管理、线程管理、低级地址空间管理、进程间通信（IPC）等。
  - 其他服务，如文件系统、设备驱动等，运行在用户模式下的服务器进程中。

- **组件**：
  - **内核模式**：包含基本的进程间通信（Basic IPC）、虚拟内存（Virtual Memory）和调度（Scheduling）。
  - **用户模式**：运行应用程序、UNIX 服务器、设备驱动服务器和文件服务器等。
  - **服务器进程**：如 UNIX 服务器、设备驱动服务器和文件服务器，提供额外的服务。

- **通信方式**：
  - 应用程序通过应用 IPC 与服务器进程通信，服务器进程再通过内核 IPC 与微内核通信。

### 3. 混合内核（"Hybrid kernel"）架构
- **特点**：
  - 结合了单体内核和微内核的优点。
  - 一些服务运行在内核模式下，而其他服务运行在用户模式下的服务器进程中。

- **组件**：
  - **内核模式**：包含基本的进程间通信（Basic IPC）、虚拟内存（Virtual Memory）和调度（Scheduling）。
  - **用户模式**：运行应用程序和 UNIX 服务器。
  - **服务器进程**：如 UNIX 服务器，提供额外的服务。
  - **设备驱动**：运行在内核模式下，直接与硬件交互。

- **通信方式**：
  - 应用程序通过应用 IPC 与 UNIX 服务器通信，UNIX 服务器再通过内核 IPC 与设备驱动通信。

### 总结
- **单体内核**：所有服务都在内核模式下运行，性能较高，但可扩展性和可维护性较差。
- **微内核**：只包含最基本的服务在内核模式下运行，其他服务在用户模式下运行，可扩展性和可维护性较好，但性能可能较低。
- **混合内核**：结合了单体内核和微内核的优点，既保持了较高的性能，又提高了可扩展性和可维护性。

每种架构都有其适用的场景和优缺点，选择哪种架构取决于系统设计的具体需求。

**总结**
对于内核的架构一般有这三种类型:

- 宏内核，包含多个模块，整个内核像一个完整的程序;
- 微内核，有一个最小版本的内核，一些模块和服务则由用户态管理;
- 混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序;

Linux 的内核设计是采用了宏内核，Window 的内核设计则是采用了混合内核。
这两个操作系统的可执行文件格式也不一样， Linux 可执行文件格式叫作 ELF，Windows 可执行文件格式叫作 PE。



## 系统调用

这些是 Unix 和类 Unix 系统（如 Linux）中常见的系统调用，它们用于进程管理、文件操作、内存管理等。以下是对每个系统调用的详细介绍：

### 1. **fork()**
- **功能**：创建一个新的进程，称为子进程。
- **工作原理**：
  - 调用 `fork()` 时，当前进程（父进程）会创建一个几乎完全相同的副本作为子进程。
  - 子进程继承父进程的代码段、数据段、堆栈等资源，但它们是独立的进程，有自己的进程 ID（PID）。
  - `fork()` 返回值：
    - 在父进程中返回子进程的 PID。
    - 在子进程中返回 0。
- **用途**：常用于并发处理，如多进程服务器、并行计算等。

### 2. **exit()**
- **功能**：终止当前进程。
- **工作原理**：
  - 当一个进程调用 `exit()` 时，它会释放所有分配给它的资源（如文件描述符、内存等）。
  - 进程的状态会变为“僵尸”状态，直到父进程通过 `wait()` 或 `waitpid()` 收回它的状态信息。
- **用途**：用于正常结束进程，避免资源泄漏。

### 3. **wait()**
- **功能**：父进程等待子进程结束。
- **工作原理**：
  - 父进程调用 `wait()` 后，会阻塞，直到某个子进程结束。
  - `wait()` 返回时，会提供子进程的退出状态。
- **用途**：防止子进程变成僵尸进程，确保父进程可以获取子进程的退出信息。

### 4. **kill(pid)**
- **功能**：发送信号给指定的进程。
- **工作原理**：
  - 默认情况下，`kill(pid)` 会发送 `SIGTERM` 信号，通知进程终止。
  - 进程可以捕获和处理某些信号，但 `SIGKILL` 信号不能被捕获，会直接终止进程。
- **用途**：用于强制结束进程，例如在进程未响应时。

### 5. **getpid()**
- **功能**：获取当前进程的进程 ID（PID）。
- **工作原理**：
  - 返回当前进程的唯一标识符。
- **用途**：用于进程间通信、日志记录等。

### 6. **sleep(n)**
- **功能**：使当前进程暂停执行指定的秒数。
- **工作原理**：
  - 进程进入睡眠状态，不会占用 CPU 时间。
  - 睡眠结束后，进程会恢复执行。
- **用途**：用于延时操作，例如在循环中减少 CPU 使用率。

### 7. **exec(filename, *argv)**
- **功能**：加载并执行指定的程序。
- **工作原理**：
  - 替换当前进程的代码段、数据段等，加载新程序的代码。
  - `exec()` 不会创建新进程，而是直接在当前进程中运行新程序。
- **用途**：用于在不退出当前进程的情况下运行其他程序。

### 8. **sbrk(n)**
- **功能**：增加进程的堆空间。
- **工作原理**：
  - 调整进程的堆空间大小，增加或减少 `n` 字节。
- **用途**：用于动态内存分配，但现代程序更倾向于使用 `malloc()` 等库函数。

### 9. **open(filename, flags)**
- **功能**：打开文件。
- **工作原理**：
  - 根据 `flags` 指定的模式（如只读、只写、追加等）打开文件。
  - 返回一个文件描述符（FD），用于后续的文件操作。
- **用途**：用于文件读写操作的开始。

### 10. **read(fd, buf, n)**
- **功能**：从文件中读取数据。
- **工作原理**：
  - 从文件描述符 `fd` 指向的文件中读取最多 `n` 个字节到缓冲区 `buf`。
  - 返回实际读取的字节数。
- **用途**：用于从文件中读取数据。

### 11. **write(fd, buf, n)**
- **功能**：向文件写入数据。
- **工作原理**：
  - 将缓冲区 `buf` 中的 `n` 个字节写入文件描述符 `fd` 指向的文件。
  - 返回实际写入的字节数。
- **用途**：用于向文件中写入数据。

### 12. **close(fd)**
- **功能**：关闭文件描述符。
- **工作原理**：
  - 关闭文件描述符 `fd`，释放相关资源。
- **用途**：用于结束文件操作，避免资源泄漏。

### 13. **dup(fd)**
- **功能**：复制文件描述符。
- **工作原理**：
  - 创建一个新的文件描述符，指向与 `fd` 相同的文件。
- **用途**：用于文件描述符的备份或重定向。

### 14. **pipe(p)**
- **功能**：创建管道。
- **工作原理**：
  - 创建一个管道，返回两个文件描述符 `p[0]` 和 `p[1]`。
  - `p[0]` 用于读取，`p[1]` 用于写入。
- **用途**：用于进程间通信，例如父子进程之间的数据传递。

### 15. **chdir(dirname)**
- **功能**：改变当前工作目录。
- **工作原理**：
  - 将当前工作目录切换到指定的目录 `dirname`。
- **用途**：用于文件操作时切换目录。

### 16. **mkdir(dirname)**
- **功能**：创建新目录。
- **工作原理**：
  - 创建一个名为 `dirname` 的新目录。
- **用途**：用于组织文件结构。

### 17. **mknod(name, major, minor)**
- **功能**：创建设备文件。
- **工作原理**：
  - 创建一个设备文件（如字符设备或块设备）。
  - `major` 和 `minor` 是设备号。
- **用途**：用于创建设备文件，通常用于驱动程序开发。

### 18. **fstat(fd)**
- **功能**：获取文件状态信息。
- **工作原理**：
  - 返回文件描述符 `fd` 指向的文件的状态信息，如文件大小、权限等。
- **用途**：用于文件信息查询。

### 19. **link(f1, f2)**
- **功能**：创建硬链接。
- **工作原理**：
  - 为文件 `f1` 创建一个新的名字 `f2`，指向同一个文件。
- **用途**：用于文件的别名管理。

### 20. **unlink(filename)**
- **功能**：删除文件。
- **工作原理**：
  - 删除文件名 `filename`，如果文件没有其他链接，则文件也会被删除。
- **用途**：用于删除文件。

这些系统调用是 Unix 系统编程的基础，广泛应用于各种程序中。

## 程序与进程

进程和程序是计算机系统中两个密切相关但又不同的概念。它们之间的关系可以从以下几个方面来理解：

### 1. **定义**
- **程序**：
  - 程序是一组指令的集合，这些指令用某种编程语言编写，用于完成特定的任务。
  - 程序是静态的，它存储在磁盘或其他存储介质中，是一个可执行文件（如 `.exe` 文件在 Windows 系统中，或可执行的二进制文件在 Unix/Linux 系统中）。
  - 程序本身不会运行，它只是一个代码的集合。

- **进程**：
  - 进程是程序在计算机上的一个运行实例。它是操作系统分配资源（如 CPU 时间、内存等）的基本单位。
  - 进程是动态的，它表示程序在执行过程中的状态和行为。
  - 每次运行程序时，操作系统会创建一个新的进程来执行该程序。

### 2. **关系**
- **程序是进程的模板**：
  - 程序是进程的静态表示。它定义了进程运行时需要执行的指令和数据。
  - 当程序被加载到内存中并开始执行时，它就变成了一个进程。

- **进程是程序的运行实例**：
  - 每个进程都是一个独立的运行环境，它有自己的内存空间、文件描述符、状态信息等。
  - 同一个程序可以同时运行多个进程。例如，多个用户可以同时运行同一个文本编辑器程序，每个用户运行的实例就是一个独立的进程。

### 3. **区别**
- **静态与动态**：
  - 程序是静态的，它是一个存储在磁盘上的文件。
  - 进程是动态的，它是一个正在运行的程序实例。

- **资源分配**：
  - 程序本身不占用系统资源。
  - 进程会占用系统资源，如内存、CPU 时间、文件描述符等。

- **生命周期**：
  - 程序的生命周期从创建到删除，通常是一个长期的过程。
  - 进程的生命周期从创建到终止，是一个短暂的过程。

### 4. **示例**
假设你有一个名为 `my_program` 的程序，它是一个简单的计算器程序。以下是程序和进程的关系示例：

- **程序**：
  - `my_program` 是一个可执行文件，存储在磁盘上。
  - 它包含了一系列指令，用于实现计算器的功能。

- **进程**：
  - 当你在终端中运行 `my_program` 时，操作系统会加载 `my_program` 到内存中，并创建一个新的进程。
  - 这个进程有自己的内存空间，用于存储程序的指令和数据。
  - 进程有自己的状态信息，如当前执行的指令指针、寄存器内容等。
  - 当你退出计算器程序时，这个进程会终止，操作系统会回收分配给它的资源。

### 5. **总结**
- **程序** 是一个静态的代码集合，定义了如何执行任务。
- **进程** 是程序的一个运行实例，是动态的，操作系统会为它分配资源。
- **程序是进程的模板，进程是程序的运行实例**。

理解程序和进程的关系对于系统编程和操作系统的理解非常重要。