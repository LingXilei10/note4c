声明静态变量，使其**生命周期延长**或作用域限定在当前文件内/函数内。

声明静态函数，使其作用域限定在当前文件内。

声明静态成员变量，使其属于类本身而不是对象，多个对象共享同一份内存。

使用静态限定符，控制变量的初始化和生命周期。



### 举例：

### 1.在函数内部使用static：

```
#include <stdio.h>

void increment() {
    static int count = 0;
    count++;
    printf("调用次数：%d\n", count);
}

int main() {
    for (int i = 0; i < 5; i++) {
        increment();
    }
    return 0;
}
```

在每次调用 `increment` 函数时，`count` 的值会持续增加，而不会被重置。这是因为 `count` 被声明为 `static`，其**生命周期跨越了函数调用**。

### 2.在文件作用域使用static：

```
// File1.c
static int globalVar = 10; //变量只可在file1.c里使用

// File2.c
extern int globalVar;
int main() {
    printf("globalVar 的值：%d\n", globalVar);
    return 0;
}
```

在 File1.c 文件中，我们声明了一个**具有文件作用域的静态全局变量** `globalVar`。

即使**在其他文件中使用 `extern` 声明也无法访问到它**。



静态变量在编程中具有多种重要作用，具体如下：

1. **共享状态**：静态变量属于类而非类的实例。这意味着**所有的实例都共享同一个静态变量**，可以用来存储全局状态或计数器。

2. **内存管理**：静态变量在程序的**整个运行期间都存在于内存中（通常在类被加载时分配），这避免了每次创建对象时都需要分配和释放内存的开销**。

3. **类级别访问**：可以通过类名直接访问静态变量，而不需要实例化对象。这样可以方便地在不创建对象的情况下访问和修改数据。

4. **常量定义**：静态变量通常与`final`关键字一起使用来定义常量，这样可以确保其值在运行时不会被改变。

5. **控制对象实例的数量**：通过静态变量，程序可以限制一个类的实例数量，例如可以通过计数器来实现单例模式。

6. **方法访问**：静态方法只能访问静态变量，这样可以促使设计以更高的模块化和数据隔离。

如果你想了解如何在实际编程中使用静态变量，或者有具体的语言示例，也可以告诉我！



在C中，关键字static是静态变量：
静态变量只会初始化一次，然后在这函数被调用过程中值不变。
在文件内定义静态变量（函数外），作用域是当前文件，该变量可以被文件内所有函数访问，不能被其他文件函数访问。为本地的全局变量，只初始化一次。
在C++中，类内数据成员可以定义为static
对于非静态数据成员，每个对象有一个副本。而静态数据成员是类的成员，只存在一个副本，被所有对象共享。
静态成员变量没有实例化对象也可以使用，“类名：静态成员变量”
静态成员变量初始化在类外，但是private和protected修饰的静态成员不能类外访问。

```c
class Stu
{
    public:
        static int age;
    private:
        static int height;
};
//初始化静态成员变量
int Stu::age = 19;
int Stu::height = 180;

int main()
{
	cout<<Stu::age<<endl;//输出19；
	cout<<Stu::height<<endl;//错误的，私有无法访问。
	Stu s;
	cout<<s::age<<endl;//输出19；
	cout<<s::height<<endl;//错误的，私有无法访问。
	return 0;
}
```

在类中，static修饰的函数是静态成员函数。静态成员函数一样属于类，不属于对象，被对象共享。静态成员函数没有this指针，不能访问非静态的函数和变量，只能访问静态的。
与全局变量相比，静态数据成员的优势：
全局变量作用域是整个工程，而static作用域是当前文件，避免命名冲突
静态数据成员可以是private成员，而全局变量不能，实现信息隐藏
为什么静态成员变量不能在类内初始化？
因为类的声明可能会在多处引用，每次引用都会初始化一次，分配一次空间。这和静态变量只能初始化一次，只有一个副本冲突，因此静态成员变量只能类外初始化。

为什么static静态变量只能初始化一次？
所有变量都只初始化一次。但是静态变量在全局区（静态区），而自动变量在栈区。静态变量生命周期和程序一样，只创建初始化一次就一直存在，不会销毁。而自动变量生命周期和函数一样，函数调用就进行创建初始化，函数结束就销毁，所以每一次调用函数就初始化一次。

在头文件中定义静态变量是否可行？
不可行，在头文件中定义的一个static变量，对于包含该头文件的所有源文件，实质上在每个源文件内定义了一个同名的static变量。造成资源浪费，可能引起bug

静态变量什么时候初始化
初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。

在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。

而在C++中，初始化时在执行相关代码时才会进行初始化，C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。

