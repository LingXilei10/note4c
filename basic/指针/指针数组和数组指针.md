指针数组

int *p[10] 数组中的元素都是指针    10行



数组指针

int (*p)[10]  指向含有10个元素的一维数组（行指针）  10列

=int p\[][10]



**数组指针(也称为行指针)**
定义为：int( * p)[n]; （注意优先级：()>[]> \*）（int (*p)[5]定义了一个指向含有5个元素的一维数组的指针。）
当数组指针指向一个一维数组时：

```cpp
int(*p)[n];    //定义了指向含有n个元素的一维数组的指针
int a[n];        //定义数组
p=a;             //将一维数组首地址赋值给数组指针p
```

（）优先级高，说明p是指针，指向一个整型的一维数组。**这个一维数组的长度是n，也可以说p的步长为n。当p+1时，p指针会跨过n个整型数据的长度。**

当数组指针指向一个二维数组时：

```cpp
int(*p)[4];   //定义了指向含有4个元素的一维数组的指针
int a[3][4];
p=a;           //将二维数组的首地址赋值给p，也可是a[0]或&a[0][0]
p++;           //表示p跨过行a[0][],指向了行a[1][]
```

所以，数组指针也成为指向一维数组的指针，也就是行指针。

```cpp
p=a+j;
*p=a[i];  // line ith head
*p+j=a[i]+j;
*(*p+j)=a[i][j];

```



**指针数组**
定义为：int* p[n]; （注意优先级：()>[]> *）
[]> * ，所以p是数组，是一个由n个指针类型元素组成的指针数组，或者说这个当一个数组里含有的元素为指针类型的时候，它就被成为指针数组。当p+1时，则p指向下一个数组元素。（需注意，p=a；这种赋值方法是错的，因为p是一个不可知变量，只存在p[0],p[1],p[2]，但可以这样 p=a; 这里p表示指针数组第一个元素的值，a的首地址的值）
将二维数组赋值给指针数组：

```cpp
int *p[3];     //定义指针数组
int a[3][4];
for(i=0;i<3;i++)
p[i]=a[i];     //通过循环将a数组每行的首地址分别赋值给p里的元素  
```

这里int * p[3]表示一个一维数组内存放三个指针变量，分别是p[1]，p[2]，p[3]。如果要引用二维数组时，可以有多种表达方式：如表示数组中i行j列一个元素：
：* (* (p+i)+j)、(* (p+i) )[j]、p[i][j]、 * (p[i]+j)



## 题目1

在C/C++中，对于数组 `int a[6] = {1,2,3,4,5,6};`：

**`&a`** 表示 **整个数组的地址**，其类型是 `int (*)[6]`（指向长度为6的整型数组的指针）。  
虽然 `a` 和 `&a` 的数值（地址值）相同（均指向数组首元素），但二者的类型不同，这会影响指针运算：

| 表达式 | 类型         | 指针运算的步长                 |
| ------ | ------------ | ------------------------------ |
| `a`    | `int*`       | +1 移动 `sizeof(int)` 字节     |
| `&a`   | `int (*)[6]` | +1 移动 `6 * sizeof(int)` 字节 |

### 示例验证
```c
#include <stdio.h>

int main() {
    int a[6] = {1,2,3,4,5,6};
    
    printf("a 的地址: %p\n", (void*)a);     // 输出数组首元素地址
    printf("&a 的地址: %p\n", (void*)&a);   // 输出整个数组的地址（数值相同）
    
    printf("a + 1: %p\n", (void*)(a + 1));   // 移动 4 字节（假设 int 占4字节）
    printf("&a + 1: %p\n", (void*)(&a + 1)); // 移动 24 字节（6 * 4）
    
    return 0;
}
```

### 输出结果（假设 `int` 占4字节）：
```
a 的地址: 0x7ffd4d3d8a30
&a 的地址: 0x7ffd4d3d8a30
a + 1: 0x7ffd4d3d8a34
&a + 1: 0x7ffd4d3d8a48
```

### 结论
**`&a`** 是 **指向整个数组的指针**，类型为 `int (*)[6]`，在指针运算时以整个数组的大小为单位移动。



## 题目2

对于表达式 `char *buff[] = {"char","int","double"};`，分析 `*(buff+1)[1]` 的值需要明确运算符优先级和指针运算的逻辑。

---

### **关键分析步骤**

#### 1. 运算符优先级
C语言中 **`[]` 的优先级高于 `*`**，因此表达式 `*(buff+1)[1]` 等价于：
```c
*((buff+1)[1])  // 先计算 [1]，再解引用
```
而非：
```c
(*(buff+1))[1]   // 用户可能预期的逻辑
```

#### 2. 指针运算逻辑
- `buff` 是 `char*[]` 类型（指针数组），每个元素指向字符串字面量。
- `buff+1` 表示指向数组第二个元素（即 `"int"` 的地址）的指针，类型为 `char**`。
- `(buff+1)[1]` 等价于 `*(buff+1 +1)`，即取 `buff+1` 后偏移 1 个元素的位置（相当于 `buff[2]`），指向 `"double"` 的地址。
- 最后解引用 `*(buff[2])` 得到字符 `'d'`（即 `"double"` 的第一个字符）。

---

### **最终答案**
表达式 `*(buff+1)[1]` 的值为 **字符 `'d'`**，完整验证如下：

```c
#include <stdio.h>

int main() {
    char *buff[] = {"char","int","double"};
    printf("%c\n", *(buff+1)[1]); // 输出 'd'
    return 0;
}
```

---

### **深入解释**
#### 若想获取 `"int"` 的第二个字符 `'n'`，正确写法应为：
```c
(*(buff+1))[1]   // 或 buff[1][1]
```
- `*(buff+1)` 获取第二个元素（`"int"` 的地址），再取索引 `[1]` 得到字符 `'n'`。

#### 运算符优先级总结：
| 表达式           | 等价形式         | 结果  |
| ---------------- | ---------------- | ----- |
| `*(buff+1)[1]`   | `*((buff+1)[1])` | `'d'` |
| `(*(buff+1))[1]` | `buff[1][1]`     | `'n'` |

---

**结论**：`*(buff+1)[1]` 的值是 `'d'`，但需注意运算符优先级问题。