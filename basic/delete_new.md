# 释放与重新分配内存

## 释放

释放 `tmp` 指向的内存是因为我们在 C++ 中使用 `delete` 操作符。让我们详细了解这个过程：

1. **指针的作用**：
   - 在 C++ 中，指针是一个变量，它存储一个内存地址。`tmp` 是一个指向 `ListNode` 类型的指针，赋值时 `tmp = cur->next;` 使 `tmp` 指向了 `cur` 节点的下一个节点的内存地址。

2. **使用 `delete` 操作符**：
   - 当我们使用 `delete tmp;` 时，**操作符 `delete` 会根据 `tmp` 所存储的地址，释放指向的内存**。这将在低级别上执行内存管理，**即将那块内存标记为可用，因此其他代码后续可以重新分配**。

3. **确保指针的指向有效性**：
   - **释放内存并不会改变 `tmp` 本身的值，它仍然指向那个已经被释放的内存地址**。然而，使用后需要注意，不应再次访问 `tmp` 所指向的地址，因为它现在是**无效的，称为悬空指针（Dangling Pointer）**。在删除后，最好将 `tmp` 设置为 `nullptr`。

4. **防止内存泄漏**：
   - 如果不使用 `delete` 来释放 `tmp` 指向的节点，**程序将失去对那块内存的控制，导致内存泄漏**。内存泄漏是指程序分配了内存，但在不再需要时没有释放，最终可能导致**程序占用过多内存**。

### 总结
释放 `tmp` 指向的内存是通过 `delete` 操作符实现的。它确保在不再需要某个节点时适当地释放内存，避免内存泄漏，并使得内存使用更加高效和安全。


释放内存并不会改变 `tmp` 本身的值，因为 `delete` 操作符仅仅是释放了 `tmp` 指向的内存块，使得这块内存变得不再可用。以下是对这一点的详细解释：

1. **指针与内存地址**：
   - 指针（如 `tmp`）存储的是一个内存地址。在执行 `delete tmp;` 之后，`tmp` 仍然保持这个地址，但该地址所指向的内存块已经被释放，变为“无效”状态。

2. **悬空指针**：
   - 一旦内存被释放，`tmp` 依然指向原来的内存地址，但这块内存现在被标记为可用，后续的程序可能会重新分配这块内存给其他变量或对象。因此，`tmp` 变成了一个悬空指针（Dangling Pointer），即指向已释放的内存。
   - 使用悬空指针是非常危险的，因为对这块内存的访问可能导致未定义行为，程序崩溃，或者读取到不正确的数据。

3. **安全访问**：
   - 在内存被释放后，通过 `tmp` 再次访问该内存地址是不安全的。为了避免这种情况，通常推荐在删除操作后将指针设置为 `nullptr`，以指示该指针不再指向有效的内存。
   - 例如，`delete tmp; tmp = nullptr;`，这样做后，`tmp` 不再指向任何内存地址，**任何进一步尝试解引用 `tmp` 的操作将会导致运行时错误（如访问违规）**，而不会意外地读取到释放的内存。

### 总结
释放内存后，指针的值（即内存地址）不会被改变，**但指向的内存变为无效或不可用。访问已释放的内存是危险的**，可能导致程序错误，因此建议在释放后将指针设为 `nullptr`。

## 重分配

在 C++ 中，当一块内存被释放（例如，通过 `delete`），**该内存地址会被系统标记为可用**。随后，操作系统可以将这块已释放的内存分配给新的变量或对象。以下是有关如何重新分配内存的详细说明：

### 1. 内存管理概念

- **内存池**：操作系统管理着一个内存池，**所有已释放的内存块在此池中可被分配给新的请求**。当调用 `new` 或 `malloc` 分配内存时，**系统会查找可用的内存块**。
- **内存重用**：当你释放某块内存后，这块内存可能会在程序的后续执行过程中被其他内存分配请求重用。

### 2. 重新分配内存的过程

#### 使用 `new` 关键字

1. **内存分配**：
   - 当你使用 `new` 分配内存时，C++ 会在**内存池中查找足够大的空闲块并返回其地址**。例如：
   ```cpp
   ListNode* newNode = new ListNode(); // 分配内存
   ```

2. **旧内存的释放**：
   - 如果你已不再需要某个对象并想要释放其占用的内存，可以这样做：
   ```cpp
   delete oldNode;   // 释放之前的节点
   ```

3. **新对象的存储**：
   - 此后，通过 `new` 分配的内存**就有可能是刚才释放的旧内存块，也可能是其他可用内存块**。
   - 一个完整的示例：
   ```cpp
   ListNode* oldNode = new ListNode(); // 新分配一个节点
   // 使用 oldNode...
   delete oldNode; // 释放内存
   ListNode* newNode = new ListNode(); // 重新分配内存
   ```

#### 使用 `malloc` 和 `free`

- 除了 `new` 和 `delete`，还可以使用** C 的内存管理函数 `malloc` 和 `free`**，但这通常不推荐在 C++ 中使用，因为** `new` 和 `delete` 会自动调用构造函数和析构函数，更适合 C++ 对象的管理**：
  ```cpp
  ListNode* ptr = (ListNode*)malloc(sizeof(ListNode)); // 使用 malloc 分配内存
  free(ptr); // 释放内存
  ptr = (ListNode*)malloc(sizeof(ListNode)); // 重新分配内存
  ```

### 3. 内存分配的注意事项

- **避免内存泄漏**：确保每次分配的内存都有对应的释放操作。
- **使用智能指针**：C++11 引入了智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`），这使得内存管理更加安全，减少内存泄漏风险。
  ```cpp
  std::unique_ptr<ListNode> nodePtr(new ListNode()); // 使用智能指针来管理内存  ？？？？
  ```

### 总结
在 C++ 中，释放的内存可以在后续的内存请求中重新分配。在分配和释放内存时保持一致的实践非常重要，包括使用适当的分配器和智能指针，以确保内存的有效管理和减少泄漏的风险。
