以下是常见排序算法的 **稳定性、时间复杂度和空间复杂度** 的对比表格，帮助您快速理解它们的核心特性：

| **排序算法** | **稳定性**             | **时间复杂度**                                            | **空间复杂度**            | **备注**                     |
| ------------ | ---------------------- | --------------------------------------------------------- | ------------------------- | ---------------------------- |
| **冒泡排序** | 稳定                   | 最好：\( O(n) \)（已有序）<br>最坏/平均：\( O(n^2) \)     | \( O(1) \)                | 适合小规模数据               |
| **插入排序** | 稳定                   | 最好：\( O(n) \)（已有序）<br>最坏/平均：\( O(n^2) \)     | \( O(1) \)                | 适合近乎有序的数据           |
| **归并排序** | 稳定                   | 所有情况：\( O(n \log n) \)                               | \( O(n) \)（需额外空间）  | 通用稳定排序，适合大规模数据 |
|              |                        |                                                           |                           |                              |
|              |                        |                                                           |                           |                              |
| **桶排序**   | 稳定（若桶内排序稳定） | 最好：\( O(n + k) \)（均匀分布）<br>最坏：\( O(n^2) \)    | \( O(n + k) \)            | 数据需均匀分布               |
| **快速排序** | 不稳定                 | 平均：\( O(n \log n) \)<br>最坏：\( O(n^2) \)（极端分区） | \( O(\log n) \)（递归栈） | 实际应用中最快，但不稳定     |
| **堆排序**   | 不稳定                 | 所有情况：\( O(n \log n) \)                               | \( O(1) \)                | 原地排序，适合内存受限场景   |
| **选择排序** | 不稳定                 | 所有情况：\( O(n^2) \)                                    | \( O(1) \)                | 交换非相邻元素破坏稳定性     |
| **希尔排序** | 不稳定                 | 平均：\( O(n \log n) \)<br>最坏：\( O(n^2) \)             | \( O(1) \)                | 插入排序的改进版             |

---

### **关键说明**
1. **稳定性**：  
   - 稳定算法（如归并、计数排序）保证相等元素的原始顺序不变。  
   - 不稳定算法（如快速排序、堆排序）可能改变相等元素的顺序。

2. **时间复杂度**：  
   - **归并排序** 和 **堆排序** 的最坏情况下仍为 \( O(n \log n) \)，但归并是稳定的。  
   - **快速排序** 平均性能最优，但最坏情况（如已有序数组）退化为 \( O(n^2) \)。

3. **空间复杂度**：  
   - **原地排序**（如冒泡、插入、堆排序）空间复杂度为 \( O(1) \)。  
   - **非原地排序**（如归并、计数排序）需要额外空间。

4. **适用场景**：  
   - **小规模数据**：插入排序（稳定）或冒泡排序。  
   - **大规模数据**：归并排序（稳定）或快速排序（不稳定但更快）。  
   - **整数排序**：计数排序或基数排序（稳定且线性时间）。  

---

### **可视化对比**
| **算法** | 稳定 | 最优时间       | 最坏时间       | 空间         | 适用场景               |
| -------- | ---- | -------------- | -------------- | ------------ | ---------------------- |
| 归并排序 | ✔️    | \( n \log n \) | \( n \log n \) | \( O(n) \)   | 通用稳定排序           |
| 快速排序 | ❌    | \( n \log n \) | \( n^2 \)      | \( \log n \) | 内存敏感场景           |
| 计数排序 | ✔️    | \( n + k \)    | \( n + k \)    | \( n + k \)  | 小范围整数             |
| 堆排序   | ❌    | \( n \log n \) | \( n \log n \) | \( O(1) \)   | 原地排序，无需额外空间 |

---

### **总结**
- **需要稳定性**：优先选择 **归并排序、计数排序、基数排序**。  
- **追求速度**：**快速排序**（平均最快，但不稳定）。  
- **内存有限**：**堆排序** 或 **原地版本的快速排序**。  
- **特殊数据**：整数用 **计数/基数排序**，均匀分布用 **桶排序**。